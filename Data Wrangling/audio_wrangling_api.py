# -*- coding: utf-8 -*-
"""audio_wrangling_api.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B-AJ2hpZksActkt_rm0jvb4PM2fpCYQ8
"""

import pandas as pd
import os
import shutil
from google.colab import drive
from sklearn.model_selection import train_test_split
import subprocess
import numpy as np

def status_regroup(dmg):
  """
    Regroup covid status to more 

    inputs:
        - dmg: demographic data with raw covid status categories

    Returns: demographic data with columns containing new covid status categories
    """
  dmg.loc[(dmg['covid_status']=='healthy'),'status_regroup'] = 'healthy'
  dmg.loc[(dmg['covid_status']=='no_resp_illness_exposed'),'status_regroup'] = 'exposed'
  dmg.loc[(dmg['covid_status']=='positive_asymp'),'status_regroup'] = 'positive'
  dmg.loc[(dmg['covid_status']=='positive_mild'),'status_regroup'] = 'positive'
  dmg.loc[(dmg['covid_status']=='positive_moderate'),'status_regroup'] = 'positive'
  dmg.loc[(dmg['covid_status']=='recovered_full'),'status_regroup'] = 'recovered'
  dmg.loc[(dmg['covid_status']=='resp_illness_not_identified'),'status_regroup'] = 'resp_illness'

  dmg.loc[(dmg['status_regroup']=='healthy'),'covid_pos'] = 0
  dmg.loc[(dmg['status_regroup']=='recovered'),'covid_pos'] = 0
  dmg.loc[(dmg['status_regroup']=='positive'),'covid_pos'] = 1
  return dmg

def pos_neg_split(dset, dmg):
  """
    Divide demographic data into covid positive and covid negative groups 

    inputs:
        - dset: name of the dataset
        - dmg: demographic data with covid status categories

    Returns: demographic data for covid positive and covid negative groups separately without covid labels
    """
  if dset == "coswara":
    pos = dmg.loc[(dmg['covid_pos']==1)]
    neg = dmg.loc[(dmg['covid_pos']==0)]
    pos.drop(columns=['covid_status', 'status_regroup','covid_pos'])
    neg.drop(columns=['covid_status', 'status_regroup','covid_pos'])
  elif dset == "coughvid":
    pos = dmg.loc[(dmg["status"]=="COVID-19")]
    neg = dmg.loc[(dmg["status"]=="healthy")]
    pos.drop(columns=['status'])
    neg.drop(columns=['status'])

  return pos, neg

def train_test_dmg(dmg_pos, dmg_neg, test_pct, val_pct, seed):
  """
    Divide demographic data into training and test sets

    inputs:
        - dmg_pos: demographic data of covid positive population
        - dmg_neg: demographic data of covid negative population
        - test_pct: percentage of data in test set
        - val_pct: percentage of data in validation set in training set
        - seed: seed to random generator

    Returns: dictionaries containing demographic features and ids in training, validation and test sets respectively
    """
  X_train = {}
  X_val = {}
  X_test = {}
  id_train = {}
  id_val = {}
  id_test = {}

  n_pos = len(dmg_pos.index)
  n_neg = len(dmg_neg.index)
  X_pos, X_test['pos'], y_train_pos, y_test_pos = train_test_split(dmg_pos, [1]*n_pos, test_size=test_pct, random_state=seed)
  X_neg, X_test['neg'], y_train_neg, y_test_neg = train_test_split(dmg_neg, [0]*n_neg, test_size=test_pct, random_state=seed)
  X_train['pos'], X_val['pos'], y_train_pos, y_val_pos = train_test_split(X_pos, [1]*len(X_pos.index), test_size=val_pct, random_state=seed)
  X_train['neg'], X_val['neg'], y_train_neg, y_val_neg = train_test_split(X_neg, [0]*len(X_neg.index), test_size=val_pct, random_state=seed)

  id_train['pos'] = X_train['pos'].index
  id_val['pos'] = X_val['pos'].index
  id_test['pos'] = X_test['pos'].index
  
  id_train['neg'] = X_train['neg'].index
  id_val['neg'] = X_val['neg'].index
  id_test['neg'] = X_test['neg'].index

  id = {}
  id['train'] = id_train
  id['val'] = id_val
  id['test'] = id_test

  X = {}
  X['train'] = X_train
  X['val'] = X_val
  X['test'] = X_test

  return X, id

def train_test_org(dset, src, target, id):
  """
    Reorganize audio data into training vs test and covid positive vs negative folders

    inputs:
        - dset: name of the dataset
        - src: source folder of audio files
        - target: target folder of the reorganized folders
        - id: dictionary of ids organized by subset and covid label

    Returns: N/A
    """
  if not os.path.exists(target):
    os.makedirs(target)
    os.chdir(src) 

    for group in ['train','val','test']:
      for covid in ['pos','neg']:
        if dset == "coswara":
          for data_type in os.scandir():
            new_target = target+"/"+data_type.name+"/"+group+'/'+covid
            if not os.path.exists(new_target):
              os.makedirs(new_target)
            for file_ in os.scandir(data_type):
              filename = file_.name
              id = filename.split("_")[0]
              if id in id[group][covid]:
                shutil.copy(file_,new_target)
            remove_invalid(new_target)

        elif dset == "coughvid":
          new_target = target+'/coughvid/'+group+'/'+covid
          if not os.path.exists(new_target):
            os.makedirs(new_target)
          copy_target_audios(src,new_target,id[group][covid])
  else:
    print("Data already exist")

def webm_to_wav(input, output):
  """
    covert webm audio file to wav

    inputs:
        - input: input path and filename
        - output: output path and filename

    Returns: N/A
    """
  command = ['ffmpeg', '-i', input, output]
  subprocess.run(command,stdout=subprocess.PIPE,stdin=subprocess.PIPE)

def convert_webms(src, target):
  """
    Convert webm files to csv files

    inputs:
        - src: source folder of webm files
        - target: target folder of the wav files

    Returns: N/A
    """
  if not os.path.exists(target):
    os.makedirs(target)
    os.chdir(src) 
    for file_ in os.scandir():
      input = file_.name
      if input.endswith('.webm'):
        output = target+input[:-4]+'wav'
      elif input.endswith('.ogg'):
        output = target+input[:-3]+'wav'
        if not os.path.isfile(output):
          webm_to_wav(input, output)
  else:
    print("Data already exist")

def copy_target_audios(src,target,ids):
  """
    copy target udio files based on subject id

    inputs:
        - src: source folder of webm files
        - target: target folder of the wav files
        - ids: target subject ids

    Returns: N/A
    """
  if not os.path.exists(target):
    os.makedirs(target)
    os.chdir(src) 
    for id in ids:
      shutil.copy(src+id+'.wav',target)
  else:
    print("Data already exist")

def remove_invalid(dir):
  """
    remove invalid audio files in directory

    input:
        - dir: folder for audio files
    """
  os.chdir(dir)
  for file_ in os.scandir():
    if os.path.getsize(file_) < 10000:
      os.remove(file_)

def combine_audios(dir,aud_types,label):
  """
    copy target udio files based on subject id

    inputs:
        - dir: directory containing the regrouped data
        - aud_types: types of audios need combining
        - label: target label of the combined data

    Returns: N/A
    """
  if not os.path.exists(dir+'/'+label):
    for aud_type in aud_types:
      for group in ['train','val','test']:
        for covid in ['pos','neg']:
          src = dir + '/' + aud_type + '/' + group + '/' + covid 
          target = dir + '/' + label + '/' + group + '/' + covid 
          if not os.path.exists(target):
            os.makedirs(target)
            src_files = os.listdir(src)
            for file_name in src_files:
              full_file_name = os.path.join(src, file_name)
              if os.path.isfile(full_file_name):
                if not os.path.isfile(os.path.join(target, file_name)):
                  shutil.copy(full_file_name, target)
  else:
    print("Data already exist")